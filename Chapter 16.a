;-------------------------------------------------------------
; Chapter 16 - A Complex Scene, Part 2 - Online
;
; 	Complex playfield with two sprites
;
;-------------------------------------------------------------
	
        processor 6502
        
        include "vcs.h"
        include "macro.h"
        include "xmacro.h"	; timer macros

;-----------------------------------------------------------------        
; Variables SEGment
        seg.u Variables		; set Variables SEGment (uninitialized)
	org $80			; start Variables at $80

;-----------------------------------------------------------------        
; Declare variables

PFPtr		.word		; pointer to playfield data
PFIndex		.byte		; offset into playfield array
PFCount 	.byte		; lines left in this playfield segment
YPos0		.byte		; Y position of player 0 sprite
XPos0		.byte		; X position of player 0 sprite
YPos1		.byte		; Y position of player 1 sprite
XPos1		.byte		; X position of player 1 sprite

;-----------------------------------------------------------------
; Pointers to bitmap and color tables

SpritePtr0	.word		; pointer to sprite 0 bitmap table
ColorPtr0	.word		; pointer to sprite 0 color table
SpritePtr1	.word		; pointer to sprite 1 bitmap table
ColorPtr1	.word		; pointer to sprite 1 color table

;-----------------------------------------------------------------
; Temporary values for kernel

YP0		.byte		; Y counter for player 0
YP1		.byte		; Y counter for player 1
Temp		.byte		; temporary
Bitp0		.byte		; bitmap for player 0
Bitp1		.byte		; bitmap for player 1
Colp0		.byte		; color for player 0
Colp1		.byte		; color for player 1
tmpPF0		.byte		; temp playfield 0
tmpPF1		.byte		; temp playfield 1
tmpPF2		.byte		; temp playfield 2

SpriteHeight	.equ 16		; EQUate 16 with SpriteHeight

;-----------------------------------------------------------------        
; Code SEGment

	seg Code        	; set Code SEGment
        org $f000		; start Code at $f000
        
Start
	CLEAN_START		; macro to safely clear memroy and TIA
	
;-----------------------------------------------------------------        
; Set up initial pointers and player position.
; Rather than specifying specific playfile data in a lookup table
; we are using the bits located at the Data0 label to make some
; random background noise

Data0        
        lda #<Data0		; LoaD lo byte address of Data0 -> A 
        sta PFPtr		; STore A -> lo byte of playfield pointer
        lda #>Data0		; LoaD hi byte address of Data0 -> A 
        sta PFPtr+1		; STore A -> hi byte of playfield pointer 
        lda #<Frame0		; LoaD lo byte address of Frame0 -> A
        sta SpritePtr0		; STore A -> lo byte of sprite 0 pointer
        lda #>Frame0		; LoaD hi byte address of Frame0 -> A
        sta SpritePtr0+1	; STore A -> hi byte of sprite 0 pointer
        lda #<ColorFrame0	; LoaD lo byte address of ColorFrame0 -> A
        sta ColorPtr0		; STore A -> lo byte of sprite 0 color pointer
        lda #>ColorFrame0	; LoaD hi byte address of ColorFrame0 -> A
        sta ColorPtr0+1		; STore A -> hi byte of sprite 0 color pointer
        
        			; reuse data from Frame0 for sprite 1
        lda #<Frame0		; LoaD lo byte address of Frame0 -> A
        sta SpritePtr1		; STore A -> lo byte of sprite 0 pointer
        lda #>Frame0		; LoaD hi byte address of Frame0 -> A
        sta SpritePtr1+1	; STore A -> hi byte of sprite 0 pointer
        lda #<ColorFrame0	; LoaD lo byte address of ColorFrame0 -> A
        sta ColorPtr1		; STore A -> lo byte of sprite 0 color pointer
        lda #>ColorFrame0	; LoaD hi byte address of ColorFrame0 -> A
        sta ColorPtr1+1		; STore A -> hi byte of sprite 0 color pointer
        lda #242		; LoaD y0 starting position (#242) -> A
        sta YPos0		; STore A -> YPos0
        lda #200		; LoaD y1 starting position (#200) -> A
        sta YPos1		; STore A -> YPos1
        lda #38			; LoaD x(0 and 1) starting position (#38) -> A
        sta XPos0		; STore A -> XPos0
        sta XPos1		; STore A -> XPos1
        lda #1			; LoaD #1 -> A
        sta VDELP0		; updates to GRP0 will be delayed (Vertical DELay Player 0) 

NextFrame
;-----------------------------------------------------------------        
; Vertical Sync - 3 lines
	VERTICAL_SYNC		; macro gives us 3 lines of VSYNC
        
;-----------------------------------------------------------------        
; Vertical Blank - 37 lines
        TIMER_SETUP 37		; macro counts X scanlines
	
	lda #$88		; LoaD hex $88 -> A - light blue
        sta COLUBK		; STore A -> COLUBK - background playfield color
        lda #$5b		; LoaD hex $5b -> A - pink
        sta COLUPF		; STore A -> COLUPF - foreground playfield color
        lda #$68		; LoaD hex $68 -> A
        sta COLUP0		; STore A -> COLUP0 - player 0 color
        lda #1			; LoaD #1 (flag to turn mirroring on) -> A
        sta CTRLPF		; STore A -> CTRLPF - Playfield mirroring (bit D0 -> 0==normal, 1==mirrored)
        lda #72			; LoaD #72 -> A
        sta PFIndex		; STore A -> PFIndex - reset playfield offset
        
;-----------------------------------------------------------------        
; Set temporary Y counter and set horizontal position
        lda YPos0		; LoaD YPos0 -> A
        sta YP0			; STore A -> YP0 = temporary counter
        lda YPos1		; LoaD YPos1 -> A
        sta YP1			; STore A -> YP1 = temporary counter
        lda XPos0		; LoaD XPos0 -> A
        ldx #0			; LoaD #0 -> X
        jsr SetHorizPos		; Jump to SubRoutine SetHorizPos for Player 0
        lda XPos1		; LoaD XPos1 -> A
        ldx #1			; LoaD #1 -> X
        jsr SetHorizPos		; Jump to SubRoutine SetHorizPos for Player 1
        sta WSYNC		; STore A -> WSYNC
        sta HMOVE		; STore A -> HMOVE - need to apply HMOVE
        
;-----------------------------------------------------------------        
; Wait for end of VBLANK
        TIMER_WAIT		; macro waits for timer to complete

        sta WSYNC		; STore A -> WSYNC
        lda #0
        sta VBLANK		; STore A -> VBLANK
        SLEEP 31		; so timing analysis works out

;-----------------------------------------------------------------        
; Main Body - 192 lines

KernelLoop  ;******** Here *********
; Phase 0: Fetch PF0 byte
        jsr DrawSprites		;
	ldy PFIndex		; no more playfield?
        beq NoMoreLines		; exit loop
        dey			;
        lda (PFPtr),y		; load PF0
        sty PFIndex		;
        sta tmpPF0		;
        
; Phase 1: Fetch PF1 byte
        jsr DrawSprites		;
	ldy PFIndex		;
        dey			;
        lda (PFPtr),y		; load PF1
        sty PFIndex		;
        sta tmpPF1		;
        
; Phase 2: Fetch PF2 byte
        jsr DrawSprites		;
	ldy PFIndex		;
        dey			;
        lda (PFPtr),y		; load PF2
        sty PFIndex		;
        sta tmpPF2		;
        
; Phase 3: Write PF0/PF1/PF2 registers
        jsr DrawSprites		;
	lda tmpPF0		;
        sta PF0			;
        lda tmpPF1		;
        sta PF1			;
        lda tmpPF2		;
        sta PF2			;
        
; Go to next scanline
	jmp KernelLoop		;

NoMoreLines
; Set up overscan timer
	TIMER_SETUP 30		;
	lda #2			;
        sta VBLANK		;
        jsr MoveJoystick	;
        TIMER_WAIT		;
        jmp NextFrame		;

; DrawSprite subroutine called by kernel
DrawSprites
; Fetch sprite 0 values
        lda #SpriteHeight	; height in 2xlines
        sec			;
        isb YP0			; INC yp0, then SBC yp0
        bcs DoDraw0		; inside bounds?
        lda #0			; no, load the padding offset (0)
DoDraw0
        tay			; -> Y
        lda (ColorPtr0),y	; color for both lines
        sta Colp0		; -> colp0
	lda (SpritePtr0),y	; bitmap for first line
        sta GRP0		; -> [GRP0] (delayed due to VDEL)
; Fetch sprite 1 values
        lda #SpriteHeight	; height in 2xlines
        sec			;
        isb YP1			; INC yp0, then SBC yp0
        bcs DoDraw1		; inside bounds?
        lda #0			; no, load the padding offset (0)
DoDraw1
        tay			; -> Y
        lda (ColorPtr1),y	; color for both lines
        tax			;
	lda (SpritePtr1),y	; bitmap for first line
        tay			;
; WSYNC and store sprite values
        lda Colp0		;
	sta WSYNC		;
        sty GRP1		; GRP0 is also updated due to VDELP0 flag
        stx COLUP1		;
        sta COLUP0		;
; Return to caller
	rts			;

SetHorizPos
	sta WSYNC		; start a new line
        bit 0			; waste 3 cycles
	sec			; set carry flag
DivideLoop
	sbc #15			; subtract 15
	bcs DivideLoop		; branch until negative
	eor #7			; calculate fine offset
	asl			;
	asl			;
	asl			;
	asl			;
	sta RESP0,x		; fix coarse position
	sta HMP0,x		; set fine offset
	rts			; return to caller

; Read joystick movement and apply to object 0
MoveJoystick
; Move vertically
; (up and down are actually reversed since ypos starts at bottom)
	ldx YPos0
	lda #%00100000	;Up?
	bit SWCHA
	bne SkipMoveUp
        cpx #175
        bcc SkipMoveUp
        dex
SkipMoveUp
	lda #%00010000	;Down?
	bit SWCHA 
	bne SkipMoveDown
        cpx #254
        bcs SkipMoveDown
        inx
SkipMoveDown
	stx YPos0
; Move horizontally
        ldx XPos0
	lda #%01000000	;Left?
	bit SWCHA
	bne SkipMoveLeft
        cpx #1
        bcc SkipMoveLeft
        dex
SkipMoveLeft
	lda #%10000000	;Right?
	bit SWCHA 
	bne SkipMoveRight
        cpx #153
        bcs SkipMoveRight
        inx
SkipMoveRight
	stx XPos0
	rts

; Bitmap data "standing" position
Frame0
	.byte #0
        .byte #%01101100;$F6
        .byte #%00101000;$86
        .byte #%00101000;$86
        .byte #%00111000;$86
        .byte #%10111010;$C2
        .byte #%10111010;$C2
        .byte #%01111100;$C2
        .byte #%00111000;$C2
        .byte #%00111000;$16
        .byte #%01000100;$16
        .byte #%01111100;$16
        .byte #%01111100;$18
        .byte #%01010100;$18
        .byte #%01111100;$18
        .byte #%11111110;$F2
        .byte #%00111000;$F4

; Color data for each line of sprite
ColorFrame0
	.byte #$FF;
	.byte #$F6;
	.byte #$86;
	.byte #$86;
	.byte #$86;
	.byte #$C2;
	.byte #$C2;
	.byte #$C2;
	.byte #$C2;
	.byte #$16;
	.byte #$16;
	.byte #$16;
	.byte #$18;
	.byte #$18;
	.byte #$18;
	.byte #$F2;
	.byte #$F4;

; Epilogue
	org $fffc
        .word Start
        .word Start
