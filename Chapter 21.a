
	SLEEP 44	; make sure we start near the end of scanline
	ldy #$ff	; start with row = -1
ScanLoop3b
        iny		; go to next brick row
        lda #BrickHeight	; for the outer loop, we count
        sta Temp		; 'brickheight' scan lines for each row
        cpy #NBrickRows		; done drawing all brick rows?
        bcc ScanSkipSync	; no -- but don't have time to draw ball!
        jmp DoneBrickDraw	; exit outer loop
ScanLoop3a
; These instructions are skipped on lines after the brick row changes.
; We need the extra cycles.
        DRAW_BALL		; draw the ball on this line?
ScanSkipSync
	sta WSYNC
        stx COLUPF	; change colors for bricks
; Load the first byte of bricks
; Bricks are stored in six contiguous arrays (row-major)
	lda Bricks+NBL*0,y
        sta PF0		; store first playfield byte
; Store the next two bytes
	lda Bricks+NBL*1,y
        sta PF1
	lda Bricks+NBL*2,y
        sta PF2
; Here's the asymmetric part -- by this time the TIA clock
; is far enough that we can rewrite the same PF registers
; and display new data on the right side of the screen
        inx		; good place for INX b/c of timing
        nop		; yet more timing
	lda Bricks+NBL*3,y
        sta PF0
	lda Bricks+NBL*4,y
        sta PF1
	lda Bricks+NBL*5,y
        sta PF2
        dec Temp
        beq ScanLoop3b	; all lines in current brick row done?
        bne ScanLoop3a	; branch always taken
; Clear playfield from bricks loop
DoneBrickDraw
	SLEEP 6
	lda #0
        sta PF0
        sta PF1
        sta PF2

;-----------------------------------------------------------------
; Draw bottom half of screen with player sprite.
; Setup 'ysprofs' which is the calculated offset into
; sprite lookup tables (it can exceed bounds, we'll test)
; Since the sprite table is reversed, the starting offset is
; Yplyr - Ystart - SpriteHeight
	lda YPlyr		; LoaD player y position -> A
        sec			; SEt Carry flag to 1
        sbc #128-SpriteHeight	; SuBtract with Carry A-(128-SpriteHeight)
        sta YSprOfs		; STore A -> temp sprite offset
        
ScanLoop4
;-----------------------------------------------------------------
; Is this scanline within sprite bounds?
	dec YSprOfs		; DECrement temp sprite offset
	lda YSprOfs		; LoaD A -> temp sprite offset
        cmp #SpriteHeight	; CoMPare A <-> memory loc - if A==M set Z
        			; (sprite is 16 pixels high + padding)
        bcc InSprite		; Branch if Carry Clear (if Z==0)
        lda #0			; no sprite, draw the padding
InSprite
	tay			; Transfer A -> Y
        lda ColorFrame0,y	; LoaD color data (memoryaddress + y) -> A
        pha			; PusH A (color data) onto stack
        lda (SpritePtr),y 	; LoaD bitmap data (memoryaddress + y) -> A
	sta WSYNC		; STore A -> Wait for next scanline (as late as possible!)
        sta GRP0		; STore A -> sprite 0 pixels (GRaphics bitmap Player 0)
        pla			; PuLl to Accumulator - bitmap data from stack
        sta COLUP0		; STore A -> (COlor/LUminence Player 0) set sprite 0 color
        DRAW_BALL		; draw the ball on this line?
        inx			; INcrement X
        cpx #184		; ComPare X <-> 184 - set Z if equal
	bne ScanLoop4		; Branch if Z != 1 - repeat next scanline until finished

;-----------------------------------------------------------------
; 8 more pixels for bottom border, and then we'll just leave it
; on for the overscan region.
        ldy #$c8	; set the playfield color
ScanLoop5
        dey		; make a nice gradient
	lda #$ff
	sta WSYNC
        sty COLUPF	; set the playfield color
        sta PF0			; STore PF0 -> A
        sta PF1			; STore PF1 -> A
        sta PF2			; STore PF2 -> A
        lda #0			; LoaD 0 -> A
        sta GRP0		; STore GRP0 (GRaphics butmap Player 0) -> A
        inx			; INcrement X
        cpx #192		; ComPare X <-> 192 - set Z if equal
        bne ScanLoop5		; Branch if Z != 1 - repeat next scanline until finished

;-----------------------------------------------------------------
; Disable ball
	lda #0			; LoaD 0 -> A
        sta ENABL		; STore A -> ENABL - set ENAble BaLl to 0

;-----------------------------------------------------------------
; 30 lines of overscan needed, but we have lots of logic to do.
; So we're going to use the PIA timer to let us know when
; almost 30 lines of overscan have passed.
; This handy macro does a WSYNC and then sets up the timer.
	TIMER_SETUP 30		; Timer for 30 lines

;-----------------------------------------------------------------
; Check for collisions
        lda #%01000000		; Load the bitmask -> A
	bit CXP0FB		; test if BITs are set in target memory location
        			; collision between player 0 and ball?
        bne PlayerCollision	; Branch if Z != 1 (meaning logical AND - the bit was set)
        lda #%10000000		; Load the bitmask -> A
        bit CXBLPF		; test if BITs are set in target memory location
        			; collision between playfield and ball?
        bne PlayfieldCollision	; Branch if Z != 1 (meaning logical AND - the bit was set)
        beq NoCollision		; Branch if Z = 1 (result of logical AND - bit was not set)
        
;-----------------------------------------------------------------
; Now we bounce the ball depending on where it is
PlayerCollision

;-----------------------------------------------------------------
; Is the button pressed? if so, just capture the ball
	lda INPT4		; read button input
	bmi ButtonNotPressed	; skip if button not pressed - Branch if Minus 
        inc captured		; set capture flag
        bne NoCollision		; Branch Not Equal (if Z != 1)
ButtonNotPressed
	lda #0
	sta captured		; clear capture flag - STore A -> captured flag

;-----------------------------------------------------------------
; See if we bounce off of top half or bottom half  of player
; (yplyr + height/2 - yball)
	ldx #1			; LoaD 1 into X
	lda YPlyr		; LoaD player y position into A
        clc			; CLear Carry flag
        adc #SpriteHeight/2	; ADd with Carry half of the sprite height with A
        sec			; SEt Carry flag to 1
        sbc YBall		; SuBtract wity Carry A - y position of ball
        bmi StoreVel		; Branch if MInus - bottom half, bounce down
	ldx #$ff		; top half, bounce up
        bne StoreVel		; Branch Not Equal (if Z != 1)
        
PlayfieldCollision
;-----------------------------------------------------------------
; Which brick do we break?
; try the one nearest to us
	lda YBall
        ldx XBall
        jsr BreakBrick
        bmi CollisionNoBrick	; return -1 = no brick found
; Did we hit the top or the bottom of a brick?
; If top, bounce up, otherwise down
	ldx #$ff	; ball velocity = up
	cmp #BrickHeight/2	; top half of brick?
        bcc BounceBallUp	; yofs < brickheight/2
        ldx #1		; ball velocity = down
BounceBallUp
; Go to BCD mode and increment the score.
; This treats 'score' as two decimal digits,
; one in each nibble, for ADC and SBC operations.
        sed
        lda Score
        clc
        adc #1
        sta Score
        cld
        jmp StoreVel
CollisionNoBrick
; If bouncing off top of playfield, bounce down
	ldx #1
	lda YBall		; LoaD ball y position -> A
        bpl StoreVel		; Branch if PLus (if minus flag not set)

;-----------------------------------------------------------------
; Otherwise bounce up
	ldx #$ff		; LoaD $FF -> X

StoreVel
;-----------------------------------------------------------------
; Store final velocity
        stx YBallVel		; STore y ball velocity -> X

;-----------------------------------------------------------------
; Make a little sound
	txa			; Transfer X -> A
        adc #45			; ADd with Carry A + 45
	sta AUDF0		; frequency - STore A -> AUDF0 (Audio Frequency Channel 0)
        lda #6			; Load 6 -> A
        sta AVol0		; shadow register for volume - STore A -> AVOL0 (Audio Volume Channel 0)
        
NoCollision
;-----------------------------------------------------------------
; Clear collision registers for next frame
	sta CXCLR		; STore A -> CXCLR (Clear collision latches - strobe)
        
;-----------------------------------------------------------------
; Ball captured? if so, no motion
	lda Captured		; LoaD captured flag -> A
        bne DoneMovement

;-----------------------------------------------------------------
; Move ball vertically
	lda YBall		; LoaD ball y position -> A
        clc			; CLear Carry flag
        adc YBallVel		; ADd with Carry ball y velocity + A
        bne NoBallHitTop
        ldx #1
        stx YBallVel
NoBallHitTop
        sta yball		; STore A -> ball Y position

;-----------------------------------------------------------------
; Move ball horizontally
; We use an fractional counter for the ball, and we have to
; set a different HMOVE value depending on if it's left or right
        lda XBallVel		; LoaD the ball X velocity -> A	
        bmi BallMoveLeft	; Branch if Minus flag set - < 0? move left
        clc			; CLear Carry flag
        adc XBallErr		; ADd with Carry A + ball X fractional error
        sta XBallErr		; STore A -> ball x fractional error
        bcc DoneMovement ; no wrap around? done
        inc XBall        ; XBall += 1
        lda XBall
        cmp #160         ; moved off right side?
        bcc DoneMovement ; no, done
        lda #0
        sta XBall        ; wrap around to left
        beq DoneMovement ; always taken
BallMoveLeft
	clc
        adc XBallErr
        sta XBallErr
        bcs DoneMovement
        dec XBall	; decrement xball
        lda XBall
        cmp #160
        bcc DoneMovement
        lda #159
        sta XBall
DoneMovement
;-----------------------------------------------------------------
; Joystick player movement
; For up and down, we INC or DEC the Y Position
	lda #%00010000		; LoaD bitmask -> A (***Up?)
	bit SWCHA 		; BIt Test Target <-> A (logical AND between target and Accum)
        			; and sets Z flag to 1 if the bits are equal
	bne SkipMoveUp0		; Branch if Z flag is Not Equal to 1
        ldx YPlyr		; LoaD player 0 y pos -> X
        cpx #129		; ComPare X -> #129 ("bottom" extent)
        bcc SkipMoveUp0		; Branch if Carry Clear
        dex			; DEcrement X
        stx YPlyr		; STore player 0 Y position -> X
        lda captured		; captured? move the ball too - LoaD captured -> A
        beq SkipMoveUp0		; Branch if EQual (if Z == 1) - set at bit above
        dec YPlyr
SkipMoveUp0
	lda #%00100000		; LoaD bitmask -> A (***Down?)
	bit SWCHA 		; BIt Test Target <-> A (logical AND between target and Accum)
	bne SkipMoveDown0	; Branch if Z flag is Not Equal to 1
        ldx YPlyr		; LoaD player 0 y position -> X
        cpx #185-SpriteHeight	; ComPare X -> #185 ("top" extent)
        bcs SkipMoveDown0	; Branch if Carry Set
        inx			; INcrement X
        stx YPlyr		; STore X -> player 0 Y positoin
        lda captured		; captured? move the ball too - LoaD captured -> A
        beq SkipMoveDown0	; Branch if EQual (if Z == 1) - set at bit above
        inc YBall
SkipMoveDown0
;-----------------------------------------------------------------
; Note that the horizontal position is not contained in RAM,
; but inaccessibly inside the TIA's registers! Some games can
; get away with this if they use the collision registers.
	ldx #0			; assume speed is 0 if no movement
; We'll test the left/right flags using a special feature of
; the BIT instruction, which sets the N and V flags to the
; 7th and 6th bit of the target.
        bit SWCHA
	bvs SkipMoveLeft0	; V flag set?
        lda XPlyr
        beq SkipMoveLeft0 ; don't allow move left of screen
        dec XPlyr
        lda Captured
        beq SkipMoveLeft0
        dec XBall	; if captured, also move the ball
SkipMoveLeft0
	bit SWCHA
	bmi SkipMoveRight0	; N flag set?
        lda XPlyr
        cmp #150
        bcs SkipMoveRight0 ; don't allow move right of screen
        inc XPlyr
        lda Captured
        beq SkipMoveRight0
        inc XBall	; if captured, also move the ball
SkipMoveRight0
; Set ball position using SetHorizPos
	lda XBall
        ldx #4
        jsr SetHorizPos2
; Set player position using SetHorizPos
	lda XPlyr
        ldx #0
        jsr SetHorizPos2

;-----------------------------------------------------------------
; Play audio from shadow register?
	ldx AVol0		; Load audio volume channel 0 shadow register -> X
        beq NoAudio		; Branch if Z == 1 (set by beq NoCaptureMove0)
        dex			; decrement volume every frame
	stx AUDV0		; store in volume hardware register
        stx AVol0		; store in shadow register
        lda #3			; 
        sta AUDC0		; shift counter mode 3 for weird bounce sound

NoAudio
;-----------------------------------------------------------------
; Wait until our timer expires and then WSYNC, so then we'll have
; passed 30 scanlines. This handy macro does this.
	TIMER_WAIT

;-----------------------------------------------------------------
; Goto next frame
        jmp NextFrame

;-----------------------------------------------------------------

; Subroutine to try to break a brick at a given X-Y coordinate.
; X contains the X coordinate.
; A contains the Y coordinate.
; On return, A = -1 if no brick was present,
; otherwise A = Y offset (0-brickheight-1) of brick hit.
BreakBrick
        ldy #$ff
        sec
        sbc #BrickYStart	; subtract top Y of brick field
; Divide by brick height
DivideRowLoop
	iny
        sbc #BrickHeight
	bcs DivideRowLoop	; loop until < 0
        cpy #NBrickRows
        bcs NoBrickFound
; Now that we have the line, get byte and bit offset for brick
	clc
        adc #BrickHeight
	pha	; save the remainder to return as result
	txa
        clc
        adc #3	; adjust because SetHorizPos is off by a few pixels
        lsr
        lsr	; divide X coordinate by 4
        tax	; transfer brick column to X
        tya	; load brick row # in A
        clc
        adc PFOfsTable,x	; add offset
        tay
        lda PFMaskTable,x
        eor #$ff
        and Bricks,y
        cmp Bricks,y		; was there a change?
        beq NoBrickFound2	; no, so return -1 as result
        sta Bricks,y
        pla		; return remainder as result
        rts
NoBrickFound2
	pla		; pull the remainder, but ignore it
NoBrickFound
	lda #$FF	; return -1 as result
        rts

; SetHorizPos2 - Sets the horizontal position of an object.
; The X register contains the index of the desired object:
;  X=0: player 0
;  X=1: player 1
;  X=2: missile 0
;  X=3: missile 1
;  X=4: ball
; This routine does a WSYNC both before and after, followed by
; an HMOVE and HMCLR. So it takes two scanlines to complete.

SetHorizPos2
        sec			; set carry flag
        sta WSYNC		; start a new line
	sta HMCLR
DivideLoop
	sbc #15			; subtract 15
	bcs DivideLoop		; branch until negative
	eor #7			; calculate fine offset
        asl
        asl
        asl
        asl
        sta HMP0,x		; set fine offset
        sta RESP0,x		; fix coarse position
        sta WSYNC		; Wait for Sync
        sta HMOVE		; apply the previous fine position(s)
        rts			; return to caller 

;-----------------------------------------------------------------
; Height of our sprite in lines
SpriteHeight equ 17

;-----------------------------------------------------------------
; Bitmap data "standing" position
Frame0
	.byte #0
        .byte #%01101100;$F6
        .byte #%00101000;$86
        .byte #%00101000;$86
        .byte #%00111000;$86
        .byte #%10111010;$C2
        .byte #%10111010;$C2
        .byte #%01111100;$C2
        .byte #%00111000;$C2
        .byte #%00111000;$16
        .byte #%01000100;$16
        .byte #%01111100;$16
        .byte #%01111100;$18
        .byte #%01010100;$18
        .byte #%01111100;$18
        .byte #%11111110;$F2
        .byte #%00111000;$F4

;-----------------------------------------------------------------
; Bitmap data "throwing" position
Frame1
	.byte #0
        .byte #%01101100;$F6
        .byte #%01000100;$86
        .byte #%00101000;$86
        .byte #%00111000;$86
        .byte #%10111010;$C2
        .byte #%10111101;$C2
        .byte #%01111101;$C2
        .byte #%00111001;$C2
        .byte #%00111000;$16
        .byte #%01101100;$16
        .byte #%01111100;$16
        .byte #%01111100;$18
        .byte #%01010100;$18
        .byte #%01111100;$18
        .byte #%11111110;$F2
        .byte #%00111000;$F4

;-----------------------------------------------------------------
; Color data for each line of sprite
ColorFrame0
	.byte #$FF		; ball color if not sharing line with player sprite
        .byte #$F6;
        .byte #$86;
        .byte #$86;
        .byte #$86;
        .byte #$C2;
        .byte #$C2;
        .byte #$C2;
        .byte #$C2;
        .byte #$16;
        .byte #$16;
        .byte #$16;
        .byte #$18;
        .byte #$18;
        .byte #$18;
        .byte #$F2;
        .byte #$F4;

;-----------------------------------------------------------------
; Bitmap pattern for digits
DigitsBitmap ;;{w:8,h:5,count:10,brev:1};;
        .byte $EE,$AA,$AA,$AA,$EE
        .byte $22,$22,$22,$22,$22
        .byte $EE,$22,$EE,$88,$EE
        .byte $EE,$22,$66,$22,$EE
        .byte $AA,$AA,$EE,$22,$22
        .byte $EE,$88,$EE,$22,$EE
        .byte $EE,$88,$EE,$AA,$EE
        .byte $EE,$22,$22,$22,$22
        .byte $EE,$AA,$EE,$AA,$EE
        .byte $EE,$AA,$EE,$22,$EE

; Playfield bitmasks for all 40 brick columns
PFMaskTable
	REPEAT 2
	.byte #$10,#$20,#$40,#$80
	.byte #$80,#$40,#$20,#$10,#$08,#$04,#$02,#$01
	.byte #$01,#$02,#$04,#$08,#$10,#$20,#$40,#$80
        REPEND

; Brick array byte offsets for all 40 brick columns
PFOfsTable
	.byte NBL*0,NBL*0,NBL*0,NBL*0
	.byte NBL*1,NBL*1,NBL*1,NBL*1, NBL*1,NBL*1,NBL*1,NBL*1
	.byte NBL*2,NBL*2,NBL*2,NBL*2, NBL*2,NBL*2,NBL*2,NBL*2
	.byte NBL*3,NBL*3,NBL*3,NBL*3
	.byte NBL*4,NBL*4,NBL*4,NBL*4, NBL*4,NBL*4,NBL*4,NBL*4
	.byte NBL*5,NBL*5,NBL*5,NBL*5, NBL*5,NBL*5,NBL*5,NBL*5

;-----------------------------------------------------------------
; Epilogue
        org $fffc		; start at $fffc
        .word Start		; reset vector at $fffc
        .word Start		; interrupt vector at $fffe (unused in VCS)
